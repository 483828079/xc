server:
  port: 50101 #服务端口

spring:
  application:
    name: xc-govern-center

eureka:
  client:
    registerWithEureka: false #服务注册，是否将自己注册到Eureka服务中
    fetchRegistry: false #服务发现，是否从Eureka中获取注册信息
    serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口）
      defaultZone: http://localhost:50101/eureka/
  server:
    enable-self-preservation: false #是否开启自我保护模式
    eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000）


  # 服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，
  # 当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，
  # 然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。

  # 当服务注册中心Eureka Server检测到服务提供者因为宕机、网络原因不可用时，
  # 则在服务注册中心将服务置为DOWN状态，并把当前服务提供者状态向订阅者发布，
  # 订阅过的服务消费者更新本地缓存。

  # 服务提供者在启动后，周期性（默认30秒）向Eureka Server发送心跳，
  # 以证明当前服务是可用状态。Eureka Server在一定的时间（默认90秒）未收到客户端的心跳，
  # 则认为服务宕机，注销该实例。

  # 自我保护模式
  # 在默认配置中，Eureka Server在默认90s没有得到客户端的心跳，则注销该实例，
  # 但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，
  # 但是因为网络分区故障时，Eureka Server注销服务实例则会让大部分微服务不可用，
  # 这很危险，因为服务明明没有问题。
  # 为了解决这个问题，Eureka 有自我保护机制，通过在Eureka Server配置如下参数，可启动保护机制
  # eureka.server.enable-self-preservation=true
  # 它的原理是，当Eureka Server节点在短时间内丢失过多的客户端时（可能发送了网络故障），
  # 那么这个节点将进入自我保护模式，不再注销任何微服务，当网络故障回复后，
  # 该节点会自动退出自我保护模式。


  # Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，
  # 剩余的节点依然可以提供注册和查询服务。
  # 而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，
  # 只要有一台Eureka还在，
  # 就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。

  # Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，
  # 那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
  # 1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
  # 2. Eureka仍然能够接受新服务的注册和查询请求，
  #    但是不会被同步到其它节点上(即保证当前节点依然可用)
  # 3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中

